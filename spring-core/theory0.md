# Введение в Spring

## Модули

- **Spring Core**. Контейнер компонентов Spring Beans и поддерживающие утилиты.
- **Spring Context**. Интерфейс ApplicationContext, пользовательский интерфейс,
  проверка достоверности, интерфейс JNDI, компоненты Eпterprise JavaBeaпs (EJB),
  удаленное взаимодействие и поддержка почты.
- **Spring ОАО**. Поддержка инфраструктуры обработки транзакций, интерфейса Java
  Database Coппectivity (JDBC) и объектов доступа к данным (DAO).
- **Spring ORM**. Поддержка технологий Hibernate, iBATIS и Java Data Objects (
  JDO).
- **Spring АОР**. Реализация аспектно-ориентированного программирования (АОП),
  согласованная с набором интерфейсов АОР Alliance.
- **Spring Web**. Базовые средства интеграции, включая составные функциональные
  средства, инициализацию контекста с помощью приемников сервлетов и
  неб-ориентированный контекст приложений.
- **Spring Web МVС**. Каркас для построения веб-приложений по проектному
  шаблону "модель-представление-контроллер" (Model-View-Controller - МУС).

## Инверсия управления и внедрение зависимостей

### Типы инверсии управления

- **_Поиск зависимостей_** - является намного более традиционным подходом и на  
  первый взгляд выглядит более знакомым тем, кто программирует на Java.
- **_Внедрения зависимостей_** - в действительности обеспечивает более высокую
  гибкость и удобство применения по сравнению с поиском зависимостей, хотя
  поначалу он кажется нелогичным.

Если инверсия управления реализуется как поиск зависимостей, то компонент
должен получить ссылку на зависимость, тогда как при внедрении зависимостей
последние внедряются в компонент контейнером инверсии управления.
У **_поиска зависимостей_** имеются две разновидности:

- извлечение зависимостей и
- контекстный поиск зависимостей (CDL).

И у **_внедрения зависимостей_** имеются две разновидности:

- через конструктор и
- через метод установки.

### Извлечение зависимостей

Извлечение зависимостей предоставляется и в каркасе Spring как механизм для
извлечения компонентов, которыми он управляет.

```java
public class DependencyPull {
    public static void main(String... args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext
                ("spring/app-context.xml");
        MessageRenderer mr = ctx.getBean("renderer", MessageRenderer.class);
        mr.render();
    }
}
```

### Контекстный поиск зависимостей

В известной мере контекстный поиск зависимостей (CDL) подобен извлечению
зависимостей, но в этом случае поиск осуществляется в контейнере, управляющем
ресурсом, а не только в каком-то центральном реестре. Как правило, контекстный
поиск зависимостей производится в установленной точке.
Механизм контекстного поиска приводится в действие через реализацию в компоненте
интерфейса:

```java
public interface ManagedComponent {
    void performLookup(Container container);
}
```

Реализуя этот интерфейс, компонент извещает контейнер, что ему требуется
получить зависимость. Контейнер обычно предоставляется базовым сервером
приложений (например, Tomcat или JBoss) или каркасом (в частности, Spring).
Интерфейс Container, предоставляющий услуги поиска зависимостей:

```java
public interface Container {
    Object getDependency(String key);
}
```

Как только контейнер будет готов передать зависимости компоненту, он вызовет
метод performLookup() по очереди для каждого компонента. И тогда компонент
сможет искать свои зависимости, используя интерфейс Container:

```java
    public class ContextualizedDependencyLookup implements ManagedComponent {
    private Dependency dependency;

    @Override
    public void performLookup(Container container) {
        this.dependency = (Dependency)
                container.getDependency("myDep");
    }

    @Override
    public String toString() {
        return dependency.toString();
    }
}

```

### Внедрение зависимостей через конструктор

Внедрение зависимостей через конструктор происходит в том случае, когда
зависимости предоставляются компоненту в его конструкторе (или нескольких
конструкторах). С этой целью в компоненте объявляется один или ряд
конструкторов,
получающих в качестве аргументов его зависимости, а контейнер инверсии
управления передает зависимости компоненту при получении его экземпляра,
как показано в приведенном ниже фрагменте кода. Очевидно, что вследствие
внедрения зависимостей через конструктор объект не может быть создан без
зависимостей, а следовательно, они обязательны.

```java
    public class ConstructionInjection {
    private Dependency dependency;

    public ConstructorInjection(Dependency dependency) {
        this.dependency = dependency;
    }

    @Override
    public String toString() {
        return dependency.toString();
    }
}

```

### Внедрение зависимостей через метод установки

При внедрении зависимостей через метод установки контейнер инверсии управления
внедряет зависимости компонента через методы установки в стиле компонентов
JavaBeans. Методы установки компонента отражают зависимости, которыми может
управлять контейнер инверсии управления. В приведенном ниже фрагменте кода
показан типичный компонент, основанный на внедрении зависимостей через метод
установки. Очевидно, что вследствие внедрения зависимостей через метод установки
объект может быть создан без зависимостей, которые могут быть предоставлены в
дальнейшем через вызов метода установки.

```java
class SetterInjection {
    private Dependency dependency;

    public void setDependency(Dependency dependency) {
        this.dependency = dependency;
    }

    @Override
    public String toString() {
        return dependency.toString;
    }
}
```

## Инверсия управления в Spring

Ядро реализации каркаса Spring основано на внедрения зависимостей, хотя в нем
обеспечиваются также возможности для поиска зависимостей.
Каркас Spring автоматически предоставляет взаимодействующие объекты зависимому
объекту, используя внедрение зависимостей. В приложении, основанном на Spring,
всегда предпочтительнее применять внедрение зависимостей для передачи
взаимодействующих объектов зависимым объектам, а не заставлять зависимые объекты
получать взаимодействующие объекты через поиск зависимостей.

Несмотря на то что внедрение зависимостей является предпочтительным механизмом
связывания вместе взаимодействующих и зависимых объектов, для доступа к
зависимым объектам понадобится и поиск зависимостей. Во многих средах Spring не
может автоматически связать все компоненты приложения с помощью внедрения
зависимостей, поэтому для доступа к первоначальному набору компонентов придется
прибегнуть к поиску зависимостей. Например, в автономных приложениях на Java
необходимо выполнить начальную загрузку контейнера Spring в методе main() и
получить зависимости (через интерфейс ApplicationContext) для программной
обработки. Но при построении веб-приложений с поддержкой проектного шаблона
MVC в Spring этого можно избежать благодаря автоматическому связыванию всего
приложения. Пользоваться внедрением зависимостей вместе с платформой Spring
следует при всякой возможности. А в крайнем случае можно обратиться к
возможностям поиска зависимостей.

Контейнер инверсии управления в Spring примечателен тем, что он может выполнять
функцию адаптера между его собственным контейнером внедрения зависимостей и
внешними контейнерами поиска зависимостей.
В каркасе Spring поддерживается внедрение зависимостей как через конструктор,
так и через метод установки, подкрепляя стандартный набор средств инверсии
управления рядом полезных дополнений и упрощая разработку в целом.

## Внедрение зависимостей в Spring

### Компоненты Spring Beans и их фабрики

Ядром контейнера внедрения зависимостей в Spring служит интерфейс BeanFactory,
который отвечает за управление компонентами Spring Beans, в том числе их
зависимостями и жизненными циклами. Термин компонент Spring Bean употребляется
в Spring для обозначения любого компонента, управляемого контейнером.  
Если в приложении требуется лишь поддержка внедрения зависимостей, то с
контейнером внедрения зависимостей в Spring можно взаимодействовать через
интерфейс BeanFactory. В этом случае в приложении необходимо создать экземпляр
класса, реализующего интерфейс BeanFactory, и сконфигурировать его на основании
сведений о компонентах Spring Beans и зависимостях. Как только это будет
сделано, компоненты Spring Beans могут быть доступны в приложении через
интерфейс BeanFactory для последующей обработки.  
В ряде случаев вся подобного рода настройка производится автоматически (
например, в веб-приложении экземпляр типа ApplicationContext будет загружаться
веб-контейнером во время начальной загрузки приложения с помощью класса
ContextLoaderListener, предоставляемого в Spring и объявленного в дескрипторном
файле web.xml). Но зачастую программировать настройку приходится вручную.   
Несмотря на то что интерфейс BeanFactory можно сконфигурировать программно,
более распространено внешнее конфигурирование с помощью определенного рода
файла конфигурации. Внутренне конфигурация компонентов Spring Beans
представлена экземплярами классов, реализующих интерфейс BeanDefinition.
Компоненты Spring Beans можно идентифицировать в интерфейсе BeanFactory, и
каждому компоненту Spring Bean может быть назначен идентификатор, имя или то и
другое.

### Реализации интерфейса BeanFactory

...

### Интерфейс ApplicationContext

Интерфейс ApplicationContext служит расширением интерфейса BeanFactory
Spring. Помимо услуг no внедрению зависимостей, интерфейс Application
Context предоставляет такие услуги, как транзакции и АОП, источник сообщений
для интернационализации (i 18n), обработка событий в приложениях и пр.
При разработке приложений, основанных на Spring, рекомендуется взаимодействовать
с Spring через интерфейс ApplicationContext. Начальная загрузка интерфейса
ApplicationContext поддерживается в Spring посредством ручного
программирования (получения экземпляра вручную и загрузки подходящей
конфигурации) или в среде веб-контейнера через класс ContextLoaderListener.

### Конфигурирование интерфейса ApplicationContext

#### СПОСОБЫ КОНФИГУРИРОВАНИЯ ПРИЛОЖЕНИЙ SPRING

Первоначально определение компонентов Spring Beans
поддерживалось через свойства или через ХМL-файл. После выпуска версии JDK 5 и
появления в Spring, начиная с версии 2.5, поддержки аннотаций Java последние
можно также применять при конфигурировании интерфейса ApplicationContext.

Применение ХМL-файла позволяет вынести всю конфигурацию за пределы кода Java,
тогда как аннотации дают разработчику возможность определять и видеть настройку
внедрения зависимостей в самом коде. В каркасе Spring допускается также сочетать
оба эти способа в одном интерфейсе ApplicationContext.

#### КРАТКОЕ ОПИСАНИЕ ПРОСТОЙ КОНФИГУРАЦИИ